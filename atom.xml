<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.euphonium.cn/"/>
  <updated>2020-02-12T03:06:25.358Z</updated>
  <id>http://www.euphonium.cn/</id>
  
  <author>
    <name>Euphonium</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>logstash学习笔记</title>
    <link href="http://www.euphonium.cn/2020/02/12/logstash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.euphonium.cn/2020/02/12/logstash%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-02-12T00:45:03.000Z</published>
    <updated>2020-02-12T03:06:25.358Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是2019年12月到2020年1月前后一个半月在一家公司实习时部门要求做的任务。原来的这个时候已经回公司接着实习了，但由于疫情学校和公司都不让实习生回去实习。这个学习笔记我在公司内部已经总结过一次了但文档不让拷贝出来，今天就重新总结一下过去两个月实习学的东西。</p><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><h4 id="logstash简介"><a href="#logstash简介" class="headerlink" title="logstash简介"></a>logstash简介</h4><p>Logstash是一个开源的服务器端数据处理管道，可以同时从多个数据源获取数据，并对其进行转换，然后将其发送到你最喜欢的“存储”。它是elastic系列下的一个产品。通常业界常说它跟Elasticsearch和Kibana共同构成ELK是当下流行的日志搜集和展示解决方案。</p><p>Logstash主要用到三个模块：input、filter、output。</p><p>Input可以从很多地方输入，比如：stdin、tcp/udp对应端口监听、数据库jdbc注入等等。在公司自测用的是从tcp端口输入。<br>Filter是我实习期间工作的重点，主要用到以下几个插件kv, dissect, translate, date, mutate, grok这些将在后面部分涉及。其中filter可以开多个pipeline来增加处理效率。<br>Output主要部分就是输出，主要应该输出到目标存储上，我开发自测是输出到stdout。</p><h4 id="filter插件"><a href="#filter插件" class="headerlink" title="filter插件"></a>filter插件</h4><p>实习期间90%的时间都是在写这个部分内容，处理各种各样的输入然后转换成一种类似键值对的格式输出到对应存储。<br>我的学习过程主要来自官方文档<a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/current/index.html</a>和项目的以前代码。以下学习笔记内容来自官方文档</p><h5 id="grok"><a href="#grok" class="headerlink" title="grok"></a>grok</h5><p>主要作用是解析非结构化数据，通过正则表达式。可以说是是最万能的但效率最差，可以用别的办法处理就不要grok</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上述代码就是一个正则匹配，如果匹配成功则把message字段（这个是输入数据的默认字段）解析成client, method, request, bytes, duration。这些字段。而前面的IP,WORD则是系统内置的正则表达式，比如IP可以解析IPv4和IPv6，NUMBER解析数字。看下面例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55.3.244.1 GET &#x2F;index.html 15824 0.043</span><br></pre></td></tr></table></figure><p>会被上面的filter解析成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client: 55.3.244.1</span><br><span class="line">method: GET</span><br><span class="line">request: &#x2F;index.html</span><br><span class="line">bytes: 15824</span><br><span class="line">duration: 0.043</span><br></pre></td></tr></table></figure><p>当然你也可以自己写解析格式（其实7成情况都是自己写的）格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;field_name&gt;the pattern here)</span><br></pre></td></tr></table></figure><p>就比如说上述的<code>%{NUMBER:duration}</code>可以改写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;duration&gt;\d+\.?\d+)</span><br></pre></td></tr></table></figure><p>grok的match功能支持将信息匹配多个正则解析式。按照顺序进行匹配，如果已经匹配到了就不用匹配后面的正则解析式。不过用多个解析式匹配非常影响效率。</p><h4 id="dissect"><a href="#dissect" class="headerlink" title="dissect"></a>dissect</h4><p>使用分隔符将非结构化事件数据提取到字段中。其实大体作用跟grok差不多，都是用于非结构化数据。但dissect提取效率更高，grok适用的情况更多。</p><p>基本匹配形式：%{a} %{b} %{c}。其中a,b,c为字段名。通过a,b,c中间的空格进行分隔，例如见下：<br>信息例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">John Smith,Big Oaks,Wood Lane,Hambledown,Canterbury,CB34RY</span><br></pre></td></tr></table></figure><p>filter部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">    dissect &#123;</span><br><span class="line">        mapping &#x3D;&gt; &#123;</span><br><span class="line">            &quot;message&quot; &#x3D;&gt; &quot;%&#123;name&#125;,%&#123;addr1&#125;,%&#123;addr2&#125;,%&#123;addr3&#125;,%&#123;city&#125;,%&#123;zip&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;name&quot;: &quot;Jane Doe&quot;,</span><br><span class="line">&quot;addr1&quot;: &quot;4321 Fifth Avenue&quot;,</span><br><span class="line">&quot;addr2&quot;: &quot;&quot;,</span><br><span class="line">&quot;addr3&quot;: &quot;&quot;,</span><br><span class="line">&quot;city&quot;: &quot;New York&quot;</span><br><span class="line">&quot;zip&quot;: &quot;87432&quot;</span><br></pre></td></tr></table></figure><p>dissect插件常用的方法就是上面的例子。其中匹配操作还可以用的“&amp;？+/”等符号，详细见官方文档。因为实际操作中我基本没用到过就不展开了。</p><h4 id="kv"><a href="#kv" class="headerlink" title="kv"></a>kv</h4><p>键值对匹配的常用解析插件，非常好用，效率也高。但对数据的格式要求很高。</p><p>详细使用通过下面例子描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">      kv &#123;</span><br><span class="line">        field_split &#x3D;&gt; &quot;;&quot;</span><br><span class="line">        #键值对和键值对之间的分隔符，默认为&quot; &quot;</span><br><span class="line">        value_split &#x3D;&gt; &quot;:&quot;</span><br><span class="line">        #键值对中间分隔符，默认为&quot;:&quot;</span><br><span class="line">        include_keys &#x3D;&gt; [ &quot;from&quot;, &quot;to&quot; ]</span><br><span class="line">        #只提取这些key值，其他的不提取</span><br><span class="line">        source &#x3D;&gt; &quot;not_the_message&quot;</span><br><span class="line">        #执行kv操作的字段值。默认为message</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>目前接触的主要用处都是通过前面三种的插件提取的时间解析信息字段，然后直接进行替换到@timestamp字段。<br>详细代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">date &#123;</span><br><span class="line">match &#x3D;&gt; [&quot;tim&quot;, &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;UNIX&quot;] #将tim字段按照</span><br><span class="line">target &#x3D;&gt; &quot;@timestamp&quot; #将tim按照覆盖到时间戳</span><br><span class="line">        timezone &#x3D;&gt; &quot;+08:00&quot; #中国东八区</span><br><span class="line"># remove_field &#x3D;&gt; [&quot;tim&quot;] #这是删除字段公共方法，详细见后</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意UNIX时间。这是从1970年1月1日午夜开始经过的秒数。实习的时候刚开始遇到过。</p><h4 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h4><p>有点类似switch case的作用。就是将一个字段映射到另外一个字段的值。</p><p>详细见代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">      translate &#123;</span><br><span class="line">        field &#x3D;&gt; &quot;[http_status]&quot;</span><br><span class="line">        #相当于switch中间的那个字段</span><br><span class="line">        destination &#x3D;&gt; &quot;[http_status_description]&quot;</span><br><span class="line">        #目标字段</span><br><span class="line">        dictionary &#x3D;&gt; &#123;</span><br><span class="line">          &quot;100&quot; &#x3D;&gt; &quot;Continue&quot;</span><br><span class="line">          &quot;101&quot; &#x3D;&gt; &quot;Switching Protocols&quot;</span><br><span class="line">          &quot;200&quot; &#x3D;&gt; &quot;OK&quot;</span><br><span class="line">          &quot;500&quot; &#x3D;&gt; &quot;Server Error&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        #从源头到目标字段的映射关系</span><br><span class="line">        fallback &#x3D;&gt; &quot;I&#39;m a teapot&quot;</span><br><span class="line">        #如果源头字段的值没有出现在&quot;dictionary&quot;中则用fallback。相当于default</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="mutate"><a href="#mutate" class="headerlink" title="mutate"></a>mutate</h4><p>很重要的后续处理插件，主要用于将解析后的字段进行处理比如改变数据类型、重命名、分割和连接、字符串大小写处理等。基本上前面的部分解析完要写入存储中，为了完成对应字段的映射以及数据格式的转换，都要靠mutate插件。<br>convert 转换数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">      mutate &#123;</span><br><span class="line">        convert &#x3D;&gt; &#123;</span><br><span class="line">          &quot;fieldname&quot; &#x3D;&gt; &quot;integer&quot;</span><br><span class="line">          &quot;booleanfield&quot; &#x3D;&gt; &quot;boolean&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>rename 字段重新命名（最常用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">      mutate &#123;</span><br><span class="line">        # Renames the &#39;HOSTORIP&#39; field to &#39;client_ip&#39;</span><br><span class="line">        rename &#x3D;&gt; &#123; &quot;HOSTORIP&quot; &#x3D;&gt; &quot;client_ip&quot; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>update 直接给字段赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">      mutate &#123;</span><br><span class="line">        update &#x3D;&gt; &#123; &quot;sample&quot; &#x3D;&gt; &quot;My new message&quot; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>剩下还有很多方法，详细见官方文档</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><h5 id="公共方法"><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h5><p>可以出现在上述任何一个插件中。主要用到add_field, remove_field这两个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">      translate &#123;</span><br><span class="line">        add_field &#x3D;&gt; &#123; &quot;message2&quot; &#x3D;&gt; &quot;Hello world&quot; &#125;</span><br><span class="line">        remove_field &#x3D;&gt; [&quot;time&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="tag-on-failure"><a href="#tag-on-failure" class="headerlink" title="tag_on_failure"></a>tag_on_failure</h5><p>这也是一个方法。用于标记匹配失败。像grok, kv, dissect这些可能会出现匹配失败的插件才有的方法。例子见下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;&quot; &#125;</span><br><span class="line">        tag_on_failure &#x3D;&gt; [&quot;parsefailure&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候如果grok正则匹配失败则tags字段会多出一个”parsefailure”值。其中tags字段专门用于记录错误匹配。</p><p><strong><em>注意：tag_on_failure是错误处理，不要用作程序的业务逻辑。一般都是标记这些匹配失败的例子专门记录到一个日志或文件中。不要通过tag_on_failure来写你的正常执行逻辑。</em></strong></p><p>例子见下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">        match &#x3D;&gt; &#123; &quot;message&quot; &#x3D;&gt; &quot;%&#123;IP:client&#125; %&#123;WORD:method&#125; %&#123;URIPATHPARAM:request&#125; %&#123;NUMBER:bytes&#125; %&#123;NUMBER:duration&#125;&quot; &#125;</span><br><span class="line">        tag_on_failure &#x3D;&gt; [&quot;parsefailure&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    if &quot;parsefailure&quot; not int [tags] &#123;</span><br><span class="line">        mutate &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过条件判断让已经出错的信息跳到最末尾执行。成功匹配的才进行后面的逻辑。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实实习过程中我也能感觉到这是一个简单的业务。因为根据这个系统的架构我不用操心input和output的部分（项目以前的代码有通用的过滤器进行处理）我只用写filter的部分拓展可以处理的信息种类即可。</p><p>差不多从实习开始两周配环境和熟悉了整个从开发到本机自测到自动化测试到git提交到写文档整个流程。后面一个月基本按照组长要求的速度完成任务。我对自己的这两个月打70分吧。因为刚开始的熟悉流程花的时间有点久。希望接下来的实习生活可以吸取教训提高效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这是2019年12月到2020年1月前后一个半月在一家公司实习时部门要求做的任务。原来的这个时候已经回公司接着实习了，但由于疫情学校和公司都
      
    
    </summary>
    
    
    
      <category term="logstash" scheme="http://www.euphonium.cn/tags/logstash/"/>
    
  </entry>
  
  <entry>
    <title>Linux-shell脚本学习</title>
    <link href="http://www.euphonium.cn/2020/02/11/Linux-shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.euphonium.cn/2020/02/11/Linux-shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-02-11T14:05:57.000Z</published>
    <updated>2020-02-11T14:08:44.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>此博文转载自我的github仓库<a href="https://github.com/euphonium1998/Shell" target="_blank" rel="noopener">https://github.com/euphonium1998/Shell</a>。为2020-02-01撰写。后续部分为原博文内容</p><hr><h1 id="Linux-shell-bash-shell"><a href="#Linux-shell-bash-shell" class="headerlink" title="Linux shell (bash shell)"></a>Linux shell (bash shell)</h1><hr><h2 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h2><p>本人学习Linux主要通过《鸟哥的Linux私房菜》进行学习，shell同理。两天阅读shell的四个章节，前三章通读，最后一章shell脚本细读。</p><p>然后今天晚上完成shell章节课后练习题共6道。比较简单而且网络上例子也很多，故较快完成。</p><hr><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>本人使用虚拟机Ubuntu以及在Windows系统下用git内嵌shell进行编写调试</p><hr><h2 id="程序实例"><a href="#程序实例" class="headerlink" title="程序实例"></a>程序实例</h2><ol><li><p>user_pwd.sh</p><ul><li><p>脚本功能：</p><p>输出目前用户名称以及目前的工作目录。</p></li><li><p>输入指令：</p><p>sh ./user_pwd.sh</p></li></ul></li><li><p>birthday.sh</p><ul><li><p>脚本功能：</p><p>以”yyyy-mm-dd”格式输入自己的下一个生日，输出目前日期离你过生日还差少天。</p></li><li><p>输入指令：</p><p>sh ./birthday.sh [date]</p><p>eg：sh ./birthday.sh 2020-04-16</p></li></ul></li><li><p>sum.sh</p><ul><li><p>脚本功能：</p><p>输入一个整数n，输出1加到n的和</p></li><li><p>输入指令：</p><p>sh ./sum.sh [n]</p><p>eg: sh ./sum.sh 10</p></li></ul></li><li><p>file.sh</p><ul><li><p>脚本功能：</p><p>判断当前目录是否有名称为”logical”文件。如果没有则用touch建立该文件。<br>如果存在该文件且不为目录，则删除该文件并创建名称为”logical”的目录。<br>如果存在该文件且为目前，则删除该目录。<br>（正好执行三遍从创建到销毁）</p></li><li><p>输入指令：</p><p>sh ./file.sh</p></li></ul></li><li><p>passwd.sh</p><ul><li><p>脚本功能：</p><p>提取/etc/passwd的用户名并打印</p></li><li><p>输入指令：</p><p>sh ./passwd.sh</p></li></ul></li><li><p>guess.sh</p><ul><li><p>脚本功能：</p><p>系统生成0~99的随机数，而用户进行输入来猜猜数字</p></li><li><p>输入指令：</p><p>sh ./guess.sh</p></li></ul></li></ol><hr><h2 id="主要遇到问题"><a href="#主要遇到问题" class="headerlink" title="主要遇到问题"></a>主要遇到问题</h2><p>额。其实没遇到啥问题。主要就是if循环</p><p>if [ condition ]; then</p><p>必须要有空格隔开，语法还不太熟。再者就是grep、cut的用法还不太熟练</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说基本学会了shell的语法，但做到以后在公司熟练编写shell脚本还是有一定距离，<br>因为目前linux指令还不是很熟。</p><p>shell脚本就是像python脚本一样，常常用于批处理。但因为效率问题肯定是不能写服务器后端。<br>对于开发工程师而言是一门很好的辅助语言跟python一样。</p><p>同时发现其实最近在公司实习的时候是有接触过shell的。比如/etc/init.d/fantom restart就是<br>通过shell实现的。<br>所以其实很多程序在后台的重启、关闭、调试是通过shell脚本的。其实shell脚本就是一批命令的集合罢了。</p><p>接下来计划学习mysql和设计模式了。疫情导致书还没发货但没办法只能看电子书了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补充&quot;&gt;&lt;a href=&quot;#补充&quot; class=&quot;headerlink&quot; title=&quot;补充&quot;&gt;&lt;/a&gt;补充&lt;/h1&gt;&lt;p&gt;此博文转载自我的github仓库&lt;a href=&quot;https://github.com/euphonium1998/Shell&quot; targe
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://www.euphonium.cn/tags/Linux/"/>
    
      <category term="shell" scheme="http://www.euphonium.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程 生产者消费者模型</title>
    <link href="http://www.euphonium.cn/2020/02/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>http://www.euphonium.cn/2020/02/11/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-02-11T14:00:39.000Z</published>
    <updated>2020-02-11T14:06:54.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>此博文转载自我的github仓库<a href="https://github.com/euphonium1998/Java-Thread" target="_blank" rel="noopener">https://github.com/euphonium1998/Java-Thread</a>。为2020-01-30撰写。后续部分为原博文内容</p><hr><h1 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h1><hr><h2 id="代码问题背景"><a href="#代码问题背景" class="headerlink" title="代码问题背景"></a>代码问题背景</h2><ul><li>模拟病人去医生看病的过程，n个病人去看病，有m个医生。医院有k个座位，病人在座位上排队，如果座位满了则这个病人出去逛一下过一段时间再回来。</li><li>将这个问题抽象成生产者-消费者模型。医生是消费者，病人是生产者。座位是仓库。</li></ul><hr><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>作者本机编译器：JDK13</p><p>不过应该JDK1.5之后的都可以用，看用到的核心代码的源码的部分全部都是“since 1.5”</p><hr><h2 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h2><p>在\out\production\Thread目录下有编译好的.class文件</p><p>输入以下指令：</p><p>java Main [doctorNum] [patientNum] [seatNum]</p><p>例如：</p><p>java Main 2 10 3</p><p>表示有2个医生，10个病人，3个座位</p><hr><h2 id="用到核心技术"><a href="#用到核心技术" class="headerlink" title="用到核心技术"></a>用到核心技术</h2><ul><li>atomic类用作计数器</li><li>BlockingQueue用来保证仓库的存和取线程安全</li><li>ReentrantLock用来保证存储打印顺序的正确性</li></ul><hr><h2 id="学习过程"><a href="#学习过程" class="headerlink" title="学习过程"></a>学习过程</h2><p>首先感谢<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943750561472" target="_blank" rel="noopener">廖雪峰Java教程</a>，<br>这个网站可以用于简单的将JavaSE过一遍，基本的功能都有介绍。但要真正做到精通还是需要阅读经典书籍。<br>等过一阵子基本开发必备知识都学完后再读《Java核心技术》</p><p>下面部分作为学习笔记记录这次学习收获：</p><ol><li>明白一些Java多线程的基本概念，比如线程之间的状态和转换，线程的启动方式有两种继承父类Thread或者重写Runnable，<br>守护进程的定义，进程的优先级等等。</li><li>synchronized的同步方法，以及和它互相协作的函数wait，notify。</li><li>从JDK1.5开始引进了ReentrantLock和Condition。Condition的await、signal函数和ReentrantLock配合使用<br>可以替代synchronized、wait，notify。ReentrantLock是个更加轻量级的锁，同时可以通过tryLock这种机制避免死锁，更加灵活。</li><li>明白理解和乐观锁和悲观锁。乐观锁是假设读取过程内容没有被改变，只在结束时进行校验，如果改变了就要上锁重新读取一遍。<br>而悲观锁则是在读取刚开始就上锁防止别的线程不管是读还是写都禁止访问。显然乐观锁适合用于读多写少的情况，<br>悲观锁适合用于读少写多的情况。ReentrantLock是悲观锁，StampedLock则可以实现乐观锁。同时CAS机制也可以算作一种乐观锁。</li><li>学会并使用了BlockingQueue。通过阅读它的源码发现它是用ReentrantLock和Condition实现的。Java还有实现了其他的线程安全集合，<br>比如ConcurrentHashMap等等。</li><li>了解使用Atomic类，通过CAS的方法实现线程安全，适合用作累加器、计数器</li><li>初步了解了用Executors创建线程池的方法，在本次代码初步阶段也是使用线程池来实现医生线程。不过后面由于线程编号的问题无法实现，<br>所以放弃使用线程池。不过在阅读网上资料过程中发现用Executors初始化线程存在很大弊端，工业上常用ThreadPoolExecutor创建线程池。</li></ol><hr><h2 id="遇到问题即解决"><a href="#遇到问题即解决" class="headerlink" title="遇到问题即解决"></a>遇到问题即解决</h2><ul><li>ClassCastExcception：</li></ul><p>这个问题主要是在初期BlockingQueue从主线程传参给医生和病人线程的时候出现问题。原来想用接口编程的，像List和ArrayList一样。<br>但是chuangdi传递给其他类的时候报错了。所以最后就统一用ArrayBlockingQueue这个类来实现阻塞队列了。</p><ul><li>打印顺序无序</li></ul><p>每个线程操作阻塞队列的时候都保证了有序性。但打印信息的时候却是无序的。所以我用ReentrantLock将操作阻塞队列外面又加了一层锁。<br>医生和病人线程同时只有一个可以操作阻塞队列（忽然发现那这样用阻塞队列的意义是什么。。用普通不就行了吗？）。同时要防止两种死锁出现：<br>在某个医生线程获得锁后调用quue.take()引起线程挂起但没有释放外层的锁，以及某个病人获得外层锁后queue.put()引起线程挂起的死锁情况。<br>这两种情况要先做条件判断后再执行后面语句。</p><ul><li>主要以上两个问题（其实主要就是问题2，以及更改过程中延伸出的其他小问题）</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算是一次最初级的Java多线程练手。主要是改写上学期的用C语言实现的操作系统实验，总的感觉和C相比，Java的很多多线程操作都封装好了，不用自己mutex，pthread_create<br>自己实现阻塞队列之类的。但是因为封装好了所以加锁的地方就可能不是个人想要的地方，就会出现实际操作正确但打印无序的新问题。</p><p>同时这次编码还有一些东西没有用到，比如线程池的使用，ThreadLocal的使用。离熟悉Java多线程还有一段路要走。</p><p>一个晚上学习，一个晚上编码，一个下午写README.md。感觉效率还行，多线程先告一段落，接下来学习shell脚本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;补充&quot;&gt;&lt;a href=&quot;#补充&quot; class=&quot;headerlink&quot; title=&quot;补充&quot;&gt;&lt;/a&gt;补充&lt;/h1&gt;&lt;p&gt;此博文转载自我的github仓库&lt;a href=&quot;https://github.com/euphonium1998/Java-Thread&quot;
      
    
    </summary>
    
    
    
      <category term="Java" scheme="http://www.euphonium.cn/tags/Java/"/>
    
      <category term="多线程" scheme="http://www.euphonium.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建与部署</title>
    <link href="http://www.euphonium.cn/2020/02/10/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <id>http://www.euphonium.cn/2020/02/10/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/</id>
    <published>2020-02-10T12:06:59.000Z</published>
    <updated>2020-02-10T14:41:39.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>其实作者本人早在2019年12月就有了建立博客的打算。但由于之前的实习以及其他优先级更高的事情导致自己建立博客这件事一直被延期。终于在春节期间找到空闲时间从2.6号开始用三个晚上时间建立博客并部署到自己的阿里云服务器上。今天2.10号抽出时间写一下建站过程。</p><hr><p>先贴出我搭建博客主要的参考的资料，感谢以下作者的帮助。</p><p>B站Up主：CodeSheep</p><p>hexo主题：cofess的pure主题。Github地址: <a href="https://github.com/cofess" target="_blank" rel="noopener">https://github.com/cofess</a></p><p>其他nginx服务器和hexo博客的配置命令参考的博文百度上太多了我也忘了我看的是谁的了。</p><h3 id="2-6日-本机部署hexo博客"><a href="#2-6日-本机部署hexo博客" class="headerlink" title="2.6日 本机部署hexo博客"></a>2.6日 本机部署hexo博客</h3><p>这个部分参考主要参考B站up主<strong><em>CodeSheep</em></strong>的搭建过程。因为我用的还是windows系统，所以不要用cmd操作，用git bash会好一些。</p><h4 id="hexo博客的原理"><a href="#hexo博客的原理" class="headerlink" title="hexo博客的原理"></a>hexo博客的原理</h4><p>hexo博客是基于node.js开发的静态博客。静态博客简单说就是用html、css、js写的网页。它没有后端，无法登陆注册账号。显示单纯的网页给用户看。</p><p>用户一般基于markdown格式写博客。然后用hexo命令将其生成网页的相关静态资源，之后再发布。</p><h4 id="hexo本机搭建步骤"><a href="#hexo本机搭建步骤" class="headerlink" title="hexo本机搭建步骤"></a>hexo本机搭建步骤</h4><ol><li><p>下载Node.js、git</p></li><li><p><code>npm install -g hexo-cli</code><br>如果觉得速度慢可以下载用cnpm然后用中国的镜像。不过我还是用<code>npm</code>。</p></li><li><p>在你想要保存博客程序的目录<code>hexo init</code></p></li><li><p><code>hexo g</code> 生成public目录。里面存着目前你写的博文网页的静态资源。</p></li><li><p><code>hexo s</code>开启服务器。可以通过<a href="localhost:4000">localhost:4000</a>访问，主要用于调试。默认有一个hello页面。</p></li><li><p>首先我将hexo博客先部署到自己的Github Pages。注意要先创建一个github的仓库，且仓库名字一定要按照格式。比如我的github名字是name123那么仓库名字一定要为name123.github.io</p></li><li><p>改变hexo的配置文件_config.yml找到如下部分按照如下添加:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;name123&#x2F;name123.github.io.git &#x2F;&#x2F;就是刚刚创建的仓库地址，前面的是一个例子</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>在博客目录执行<code>npm install hexo-deployer-git --save</code>这个东西用于部署到Github Pages</p></li><li><p>现在开始可以写博客了。按照我下面的步骤操作绝对没问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;新博文的名字&quot;</span><br><span class="line">进入source&#x2F;_post目录可以看到刚刚创建的.md博客。打开，markdown格式写博客.....</span><br><span class="line">hexo clean &#x2F;&#x2F;清理public目录</span><br><span class="line">hexo g &#x2F;&#x2F;生产现在的网站静态资源</span><br><span class="line">hexo d &#x2F;&#x2F;推到刚刚的仓库</span><br></pre></td></tr></table></figure></li><li><p>现在登录网页输入name123.github.io（就是刚刚创建的仓库名字）就可以看到刚刚部署的博客了（会有延迟）</p></li><li><p>进阶方面：如果你想要你的博客有标签、分类、关于我之类的东西。执行<code>hexo new page tags</code>就可以初始化标签功能。其他也如此。详细的这里就不介绍了。</p></li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>按照上述步骤即可完成博客部署到Github上。如果不满足于此可以看接下来的部分，部署到自己的阿里云服务器上。</p><p>其实这个部分很快就可以搞定，差不多一个小时。那天的后面部分就是买阿里云的服务器，进行远程连接，更改阿里云配置等。注意买的虚拟机默认80端口是关的，需要去打开。详细操作百度，这里不介绍了。</p><p>这个博文可能会漏一些部分（毕竟是搭完后才写的），如果配置过程不成功请自行搜索问题和思考问题。</p><h3 id="2-7日-博客部署阿里云nginx服务器"><a href="#2-7日-博客部署阿里云nginx服务器" class="headerlink" title="2.7日 博客部署阿里云nginx服务器"></a>2.7日 博客部署阿里云nginx服务器</h3><h4 id="nginx服务器下载和部署"><a href="#nginx服务器下载和部署" class="headerlink" title="nginx服务器下载和部署"></a>nginx服务器下载和部署</h4><p><strong><em>注意：以下操作部分均在阿里云机上进行操作</em></strong></p><ol><li><code>yum install -y nginx</code>安装nginx。<code>nginx</code>启动服务器。这个时候访问你的服务器ip就可以看到默认页面了。非常神奇它居然是centos的欢迎页。不知道阿里云改了啥配置</li><li><code>vim /etc/nginx/nginx.conf</code>进入nginx的配置文件。见下图<img src="/img/nginx1.jpg" width="500" /></li></ol><p>红框部分告诉我们可以自己写个conf配置文件放到<code>/etc/nginx/conf.d/</code>目录所以我创建文件<code>touch blog.conf</code>。然后用<code>vim</code>编辑文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name ;&#x2F;&#x2F;这里填云机ip或者域名</span><br><span class="line">    root ;&#x2F;&#x2F;这里填你服务器存放hexo静态资源的绝对路径</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>详细关于nginx的配置文件细节自行去了解</li></ol><h4 id="git拉取网站静态资源"><a href="#git拉取网站静态资源" class="headerlink" title="git拉取网站静态资源"></a>git拉取网站静态资源</h4><p>这个部分相对简单。就是<code>git clone</code>从上一章节讲的仓库拉取资源即可。拉取到之前server配置的文件夹即可。</p><h3 id="2-8-2-9日-选取主题，美化博客"><a href="#2-8-2-9日-选取主题，美化博客" class="headerlink" title="2.8-2.9日 选取主题，美化博客"></a>2.8-2.9日 选取主题，美化博客</h3><p>这个部分就比较简单了。因为我个人只是想用博客所以前端的一些东西了解不深，所以拉取的主题会有一些多余的功能，我做到可以完成我的审美要求即可，有些功能删掉了。</p><p>步骤基本如下：</p><ol><li>上网找到喜欢的主题</li><li>找到那个主题的github仓库。拉取下来。</li><li>按照它的安装流程改配置文件。这里特别注意。有两个配置文件主题目录下的配置文件和博客的配置文件。都是_config.yml。主要改主题目录下的配置文件，但博客的那个配置文件也要改，首先要改默认主题，如果你想用中文显示就要改语言配置，详细如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: zh-CN &#x2F;&#x2F;改为中文</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: pure &#x2F;&#x2F;新主题名为pure</span><br></pre></td></tr></table></figure>最重要的是默认主题要改<br>当然你的主题必须支持中文。这个看你的主题目录下的languages目录有没有对应的语言支持.yml文件</li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>hexo是个很简单的博客系统，非常容易搭建没啥技术。这次博客搭建主要的目的就是给自己搭一个写东西的平台。同时也通过实践学到了一些东西比如跟服务器，跟html相关的东西。</p><p>后续几天会把前阵子的东西从github搬过来，同时写一下过去一个月实习的学习笔记。然后打算写设计模式和数据库相关的学习笔记。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;其实作者本人早在2019年12月就有了建立博客的打算。但由于之前的实习以及其他优先级更高的事情导致自己建立博客这件事一直被延期。终于在春节期
      
    
    </summary>
    
    
    
      <category term="博客" scheme="http://www.euphonium.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
